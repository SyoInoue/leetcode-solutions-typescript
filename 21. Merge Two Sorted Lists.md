# １）問題

- 二つのソート済み連結リスト（singly-linked list）を結合する問題
- 連結リストの中の数字はノードと呼ばれる
- Return *the head of the merged linked list（*連結リストの先頭を返す）と書いているが、連結リストのノードは、そのノード自体の値（この問題では数値）と、次のノードへの参照（またはリンク）の両方を持っているので、結果的には連結リストそのものを返すことになる

# ２）解答

```tsx
class ListNode {
  val: number;
  next: ListNode | null;
  constructor(val?: number, next?: ListNode | null) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}

function mergeTwoLists(
  l1: ListNode | null,
  l2: ListNode | null
): ListNode | null {
  if (l1 === null) {
    return l2;
  }
  if (l2 === null) {
    return l1;
  }

  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

# ３）計算の過程

1. 最初の処理で片方空で`null`の場合にもう片方を返す処理をしている。両方`null`でない場合に下の処理へ移行
2. `if (l1.val < l2.val)` の部分で、先頭のノードの値を比較し、`l1`の方が小さい場合、中の処理に移る
3. if 文より下の部分は再帰関数（関数をその関数の中で呼び出して使う）で二つの連結リストの先頭のノードを比較して、小さい方からマージされていく。

### 例

1. **`l1`** と **`l2`** の先頭を比較します。例えば、**`l1`** が [1, 3, 5] で、**`l2`** が [2, 4, 6] とします。最初に比較すると、**`l1`** の先頭の **`1`** は **`l2`** の **`2`** より小さいので、新たなリストの先頭は **`1`** となります。
2. 次に、**`l1`** の残りの部分 **`l1.next`** （[3, 5]）と **`l2`** （[2, 4, 6]）を再帰的にマージします。同様に先頭を比較し、小さい方の **`2`** （**`l2`** の先頭）を次の要素とします。
3. この手続きをどちらかのリストがなくなるまで繰り返します。

最終的に、マージされたリストは [1, 2, 3, 4, 5, 6] となり、すべての要素がソートされています。

このプロセスは、リンクリストがあらかじめソートされていると仮定しています。つまり、それぞれのリンクリストの中で、各ノードの値は次のノードの値よりも小さいか等しいという前提があります。

# ４）備考

1. 新しい配列（例：**`l3=[]`**）が必要ないのは、「連結リスト」を操作しているから。
   1. 連結リストとは、各ノードがデータと次のノードへの参照（またはポインタ）を持つデータ構造の一種
   2. 連結リストでは、各ノードは次のノードへの参照を持っており、配列のように任意のインデックスで要素にアクセスすることはできない。したがって、連結リストを操作する際には、各ノードの「次の」リンクを更新することでリスト全体を操作す流必要がある。
