# １）問題

- 引数としてローマ数字が与えられるので、それを整数に変換する
- I を V（5）と X（10）の前に置くと、4 と 9 になる。
- X を L（50）と C（100）の前に置くと、40 と 90 になる。
- C を D（500）と M（1000）の前に置くと、400 と 900 になる。

# ２）解答

```tsx
const roman = {
  I: 1,
  V: 5,
  X: 10,
  L: 50,
  C: 100,
  D: 500,
  M: 1000,
};

function romanToInt(s: string): number {
  // まず一文字ずつ分解し新しい配列に格納して、
  // それをmapで回してromanオブジェクトから対応する値をgetする。
  const integers = s.split("").map((c) => roman[c]);

  return integers.reduce(
    (acc, x, i) => (x < integers[i + 1] ? acc - x : acc + x),
    0
  );
}
```

# ３）計算の過程

1. **`const integers = s.split('').map(c => roman[c]);`**
   1. この部分では、入力されたローマ数字の文字列 'XIV' を一文字ずつに分割し、それぞれのローマ数字の文字をその対応する整数値に変換します。**`s.split('')`** によって 'XIV' は ['X', 'I', 'V'] になり、それが **`map(c => roman[c])`** によって [10, 1, 5] に変換されます。
2. **`return integers.reduce((acc, x, i) => x < integers[i+1] ? acc - x : acc + x, 0);`**

   1. この部分では、上で得られた整数値の配列（[10, 1, 5]）を左から右に走査して一つの値にまとめます。ここでは特殊なルールが適用されており、現在の要素が次の要素より小さい場合（つまり、ローマ数字で 4 や 9 を表すような場合）、現在の要素を減算するという操作を行います。具体的には、以下のように動作します：
      - 最初に、アキュムレータ **`acc`** は初期値 0 となり、現在の要素 **`x`** は 10（'X'）です。次の要素（1）は現在の要素より小さいため、10 をアキュムレータに加えます。アキュムレータは 10 になります。
      - 次に、現在の要素 **`x`** は 1（'I'）となります。次の要素（5）は現在の要素より大きいため、今回は 1 をアキュムレータから引きます。アキュムレータは 9 になります。
      - 最後に、現在の要素 **`x`** は 5（'V'）となります。次の要素は存在しないため、5 をアキュムレータに加えます。アキュムレータは 14 になります。

   以上のようにして、ローマ数字 'XIV' が整数値 14 に変換されます。

# ４）備考

1. `split()`関数
   1. 文字列を特定の区切り文字に基づいて複数の部分文字列に分割し、配列を返す関数
   2. 空文字列（**`""`**）を渡すと、文字列の各文字が個別の要素として配列に格納される
2. `reduce()`関数
   1. 配列の全ての要素に対して指定したコールバック関数を左から右へと適用し、その結果を単一の値に「縮約」する関数
   2. コールバック関数が持つ 4 つの引数
      1. **`accumulator`**: 累積値。これは配列の各要素を順に処理する際に「蓄積」される値で、コールバック関数の戻り値が次の呼び出し時の累積値となります。
      2. **`currentValue`**: 現在処理している要素の値。
      3. **`index`**: 現在処理している要素の配列におけるインデックス。**`initialValue`** が指定されている場合は 0 から、そうでない場合は 1 から開始します。
      4. **`array`**: **`reduce()`** を呼び出した配列そのもの。
